"""Utilities for synchronizing dependency constraints.

This module keeps the short constraints file in sync with the fully pinned
``requirements.lock`` generated by ``pip-compile`` or a similar resolver. It
also validates that the dependency declarations in ``pyproject.toml`` match the
versions pinned in the constraints file.
"""

from __future__ import annotations

import logging
import tomllib
from pathlib import Path
from typing import Iterable, List, Mapping, Sequence

from packaging.requirements import Requirement
from packaging.utils import canonicalize_name
from packaging.version import Version

LOGGER = logging.getLogger(__name__)

__all__ = [
    "synchronize_constraints",
    "extract_constraints",
    "validate_pyproject_constraints",
]


def extract_constraints(lines: Iterable[str]) -> List[str]:
    """Extracts pinned package requirements from a lock file.

    Args:
        lines: The raw lines read from the lock file.

    Returns:
        An ordered list of pinned requirements suitable for a `constraints.txt` file.

    Notes:
        Comment lines, editable installs (`-e` entries), and blank lines are
        discarded. The original order is preserved to ease diff reviews.
    """

    pinned: List[str] = []
    for raw_line in lines:
        line = raw_line.strip()
        # Skip comments and empty lines to match pip's behaviour.
        if not line or line.startswith("#"):
            continue
        # Constraints cannot reference editable installs directly.
        if line.startswith("-e"):
            LOGGER.debug("Skipping editable requirement '%s'", line)
            continue
        pinned.append(line)
    return pinned


def synchronize_constraints(lock_path: Path, constraints_path: Path) -> None:
    """Synchronizes a `constraints.txt` file with a `requirements.lock` file.

    Args:
        lock_path: The path to the fully resolved lock file containing pinned
            dependencies.
        constraints_path: The destination path for the trimmed constraints file.

    Raises:
        FileNotFoundError: If the `lock_path` does not exist.
        OSError: If writing to the `constraints_path` fails.
    """

    LOGGER.debug("Reading lock file from %s", lock_path)
    lines = lock_path.read_text(encoding="utf-8").splitlines()
    pinned = extract_constraints(lines)
    LOGGER.info("Found %d pinned dependencies in %s", len(pinned), lock_path)
    contents = "\n".join(pinned)
    if contents:
        contents += "\n"
    LOGGER.debug(
        "Writing constraints file %s with %d requirements",
        constraints_path,
        len(pinned),
    )
    constraints_path.write_text(contents, encoding="utf-8")


def _parse_constraints(lines: Iterable[str]) -> Mapping[str, Version]:
    """Parses a sequence of pinned requirement strings.

    Args:
        lines: The raw requirements extracted from ``constraints.txt``.

    Returns:
        A mapping from canonical package names to :class:`packaging.version.Version`
        instances representing the pinned version for the package.

    Raises:
        ValueError: If a requirement line does not express an exact version pin.
    """

    pins: dict[str, Version] = {}
    for line in lines:
        requirement = Requirement(line)
        if not requirement.specifier:
            raise ValueError(
                f"Constraint '{line}' does not contain an exact version specifier."
            )
        specifiers = list(requirement.specifier)
        if len(specifiers) != 1 or specifiers[0].operator != "==":
            raise ValueError(
                f"Constraint '{line}' must pin a single version using '=='."
            )
        version = Version(specifiers[0].version)
        pins[canonicalize_name(requirement.name)] = version
    return pins


def _infer_lower_bound(requirement: Requirement) -> Version:
    """Extracts the minimum allowed version from a requirement specifier.

    Args:
        requirement: The requirement whose lower bound should be determined.

    Returns:
        The minimal allowed version encoded by the requirement.

    Raises:
        ValueError: If the requirement lacks a lower bound or uses ``>`` which
            cannot be satisfied by a pinned version.
    """

    lower_bound: Version | None = None
    for specifier in requirement.specifier:
        if specifier.operator == "==":
            return Version(specifier.version)
        if specifier.operator == ">=":
            candidate = Version(specifier.version)
            if lower_bound is None or candidate > lower_bound:
                lower_bound = candidate
        elif specifier.operator == "~=":
            candidate = Version(specifier.version)
            if lower_bound is None or candidate > lower_bound:
                lower_bound = candidate
        elif specifier.operator == ">":
            raise ValueError(
                f"Requirement '{requirement.name}' uses '>' which is incompatible"
                " with pinned versions."
            )
    if lower_bound is None:
        raise ValueError(
            f"Requirement '{requirement.name}' must declare a lower bound using"
            " '==', '>=', or '~=' to align with the constraints file."
        )
    return lower_bound


def _validate_requirement(
    requirement: Requirement,
    pins: Mapping[str, Version],
    scope: str,
) -> str | None:
    """Validates a single requirement against the pinned constraints.

    Args:
        requirement: The dependency declaration from ``pyproject.toml``.
        pins: Pinned versions extracted from the constraints file.
        scope: A human readable scope label (for example ``runtime`` or the name
            of an optional extra) used to annotate error messages.

    Returns:
        ``None`` when the requirement is compatible with the pinned constraints.
        Otherwise a descriptive error message is returned.
    """

    canonical_name = canonicalize_name(requirement.name)
    pinned_version = pins.get(canonical_name)
    if pinned_version is None:
        return f"{scope}: Package '{requirement.name}' is missing from the constraints file."
    if not requirement.specifier:
        return f"{scope}: Package '{requirement.name}' must declare an explicit version bound."
    if not requirement.specifier.contains(str(pinned_version), prereleases=True):
        return (
            f"{scope}: Pinned version {pinned_version} is not allowed by the"
            f" specifier '{requirement.specifier}' for package '{requirement.name}'."
        )
    try:
        lower_bound = _infer_lower_bound(requirement)
    except ValueError as exc:
        return f"{scope}: {exc}"
    if pinned_version != lower_bound:
        return (
            f"{scope}: Minimum version {lower_bound} for package '{requirement.name}'"
            f" must match the pinned version {pinned_version}."
        )
    return None


def validate_pyproject_constraints(
    pyproject_path: Path,
    constraints_path: Path,
    extras: Sequence[str] | None = None,
) -> None:
    """Ensures ``pyproject.toml`` aligns with the pinned constraints.

    Args:
        pyproject_path: Path to the project metadata file.
        constraints_path: Path to the pinned constraints file.
        extras: Optional sequence of extras to validate in addition to the
            runtime dependencies. When ``None`` an empty sequence is used.

    Raises:
        ValueError: If any dependency declarations are inconsistent with the
            pinned constraints.
    """

    extras = tuple(extras or ())
    raw_constraints = constraints_path.read_text(encoding="utf-8").splitlines()
    pins = _parse_constraints(raw_constraints)
    LOGGER.debug("Loaded %d pinned dependencies from %s", len(pins), constraints_path)

    data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
    project = data.get("project", {})
    runtime_deps = [Requirement(dep) for dep in project.get("dependencies", [])]
    optional_deps = project.get("optional-dependencies", {})

    mismatches: list[str] = []
    for requirement in runtime_deps:
        message = _validate_requirement(requirement, pins, scope="runtime")
        if message:
            mismatches.append(message)

    for extra in extras:
        group = optional_deps.get(extra)
        if group is None:
            mismatches.append(
                f"optional dependency group '{extra}' is not defined in pyproject.toml"
            )
            continue
        for requirement in (Requirement(dep) for dep in group):
            message = _validate_requirement(requirement, pins, scope=f"extra '{extra}'")
            if message:
                mismatches.append(message)

    if mismatches:
        error_details = "\n- ".join([""] + mismatches)
        raise ValueError(
            f"Dependency declarations do not match constraints:{error_details}"
        )

    LOGGER.info(
        "Validated %d runtime dependencies and %d extras against pinned versions",
        len(runtime_deps),
        len(extras),
    )
