"""Utilities for synchronizing dependency constraints.

This module keeps the short constraints file in sync with the fully pinned
``requirements.lock`` generated by ``pip-compile`` or a similar resolver.
"""

from __future__ import annotations

import logging
from pathlib import Path
from typing import Iterable, List

LOGGER = logging.getLogger(__name__)

__all__ = ["synchronize_constraints", "extract_constraints"]


def extract_constraints(lines: Iterable[str]) -> List[str]:
    """Extracts pinned package requirements from a lock file.

    Args:
        lines: The raw lines read from the lock file.

    Returns:
        An ordered list of pinned requirements suitable for a `constraints.txt` file.

    Notes:
        Comment lines, editable installs (`-e` entries), and blank lines are
        discarded. The original order is preserved to ease diff reviews.
    """

    pinned: List[str] = []
    for raw_line in lines:
        line = raw_line.strip()
        # Skip comments and empty lines to match pip's behaviour.
        if not line or line.startswith("#"):
            continue
        # Constraints cannot reference editable installs directly.
        if line.startswith("-e"):
            LOGGER.debug("Skipping editable requirement '%s'", line)
            continue
        pinned.append(line)
    return pinned


def synchronize_constraints(lock_path: Path, constraints_path: Path) -> None:
    """Synchronizes a `constraints.txt` file with a `requirements.lock` file.

    Args:
        lock_path: The path to the fully resolved lock file containing pinned
            dependencies.
        constraints_path: The destination path for the trimmed constraints file.

    Raises:
        FileNotFoundError: If the `lock_path` does not exist.
        OSError: If writing to the `constraints_path` fails.
    """

    LOGGER.debug("Reading lock file from %s", lock_path)
    lines = lock_path.read_text(encoding="utf-8").splitlines()
    pinned = extract_constraints(lines)
    LOGGER.info(
        "Found %d pinned dependencies in %s", len(pinned), lock_path
    )
    contents = "\n".join(pinned)
    if contents:
        contents += "\n"
    LOGGER.debug(
        "Writing constraints file %s with %d requirements",
        constraints_path,
        len(pinned),
    )
    constraints_path.write_text(contents, encoding="utf-8")
